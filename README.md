# OT-Machine
## Main Files

There are two main files  
* main.py contains a bit to make your own langauge. Just follow its instructions
* tambajna.py contains my conlang Tambajna's presets

Both main files allow you to either input an underlying form, or a name of a conjugation followed by an underlying form, and gives you the surface forms, generated by Optiality Theory

## Other Files
* Language.py  
 The language contains two things, the phonology, and the conjugations
* Phonology.py  
 The phonology contains a lot of information I'll go over its main two functions
  * phonologyFSA(string) creates a Finite State Automaton to get from the string as underlying form to all potential surface forms  
  It does this by producting FSAs and Finite State Transducers that represent the phonological changes and constraints
  * best(string) uses Dijkstra's algorithm to find the surface form(s) with the least weight
* FSA.py  
 FSA is the finite state automaton class. Since most of the computations use finite state machines, this is a big class  
 It stores the start state, a list of ending states, and a list of all states as if each state were a string, etc. and also a list of all edges, as FSAEdge instances
  * graphviz is a method that makes a string of that FSA that can be shown on [graphviz](http://www.webgraphviz.com/)
  * Product(fsa) takes the product of the FSA with a second FSA
  * Trim takes an FSA, and takes off all paths that don't lead to an end state
  * Dijkstra uses Dijkstra's algorithm to find the path(s) with least weight
  * determinize takes an FSA, and then determinizes it so that there are no completely blank edges ('\_' is a blank edge) and only one edge from any state that leads to a given state
  * fromRegex(regex) is a class method that takes a slightly modified non-standard version of regexes, and uses the Thompson algorithm to make an FSA
* FSAEdge.py is the class for edges in an FSA, of the form state from, state to, label, and weight
* FST.py is a class that inherets from FSA
 the main difference is that product takes an FSA, and produces an FSA after it also goes through the FST
* FSTEdge.py should make sense
* Phonotactics.py contains information about the phonotactic rules of how syllables look.
  * PhonotacticFSA is a method to make an FSA that goes through the entire phonotactics
* Assimilation.py contains the information about assimilation, vowel harmony, and related concepts
  * lists is a field that contains each harmonic group. If a sound is in multiple groups, then write it in any of them. If a sound is opaque to harmony, then put it in every list, and if it is transparent to harmony, then don't put it in any lists
  * tier is a field that is null if the harmony doesn't occur on a separate tier, and lists all symbols in that tier if it is
  * harmony FSA creates an FSA that accepts a given harmony system
 * PriorityQueue.py makes a priority queue, using a heap, that Dijktra uses
 * PQElement.py are the elements of the priority queue
 * Weight.py is the class that holds the weights.  
  This version of OT thinks that a language has a specific order it puts the different constraints in ('harm' are problems with harmony 'pen' are phonological penalties, 'bs' indicates a bad string, 'del' is for deletion, 'ins' is for insertion, and 'chg' is for when one symbol changes into another)
  This version of OT also thinks that a contender's weight is in a multiset (a 'bag') which is represented by a dict, with each key as one of the penalties, and the values as the number of a specified penalty that the contender has
